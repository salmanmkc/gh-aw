//go:build !integration

package workflow

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/github/gh-aw/pkg/testutil"
)

func TestGitPatchGeneration(t *testing.T) {
	// Create a temporary directory for the test
	tmpDir := testutil.TempDir(t, "test-*")

	// Create a test markdown file with minimal agentic workflow
	testMarkdown := `---
on:
  workflow_dispatch:
safe-outputs:
  create-pull-request:
---

# Test Git Patch

This is a test workflow to validate git patch generation.

Please do the following tasks:
1. Check current status
2. Make some changes
3. Verify the git patch is generated
`

	// Write the test file
	mdFile := filepath.Join(tmpDir, "test-git-patch.md")
	if err := os.WriteFile(mdFile, []byte(testMarkdown), 0644); err != nil {
		t.Fatalf("Failed to write test markdown file: %v", err)
	}

	// Create compiler with verbose enabled for testing
	compiler := NewCompiler()

	// Compile the workflow
	if err := compiler.CompileWorkflow(mdFile); err != nil {
		t.Fatalf("Failed to compile workflow: %v", err)
	}

	// Read the generated lock file
	lockFile := filepath.Join(tmpDir, "test-git-patch.lock.yml")
	content, err := os.ReadFile(lockFile)
	if err != nil {
		t.Fatalf("Failed to read generated lock file: %v", err)
	}

	lockContent := string(content)

	// NOTE: Git patch generation has been moved to the safe-outputs MCP server
	// The patch is now generated when create_pull_request or push_to_pull_request_branch
	// tools are called within the MCP server, not as a separate workflow step.

	// Verify git patch generation step does NOT exist in main job anymore
	if strings.Contains(lockContent, "- name: Generate git patch") {
		t.Error("Did not expect 'Generate git patch' step in main job (now handled by MCP server)")
	}

	// The patch generation script commands should NOT be in the main job
	// Note: git commands may still appear elsewhere in the workflow (e.g., checkout, git config)
	mainJobIndex := strings.Index(lockContent, "execute_agentic_workflow:")
	createPRJobIndex := strings.Index(lockContent, "safe_outputs:")

	var mainJobContent string
	if mainJobIndex != -1 && createPRJobIndex != -1 {
		mainJobContent = lockContent[mainJobIndex:createPRJobIndex]
	} else if mainJobIndex != -1 {
		mainJobContent = lockContent[mainJobIndex:]
	}

	// Check that the main job doesn't have patch generation commands
	if strings.Contains(mainJobContent, "git format-patch") {
		t.Error("Did not expect 'git format-patch' command in main job (now handled by MCP server)")
	}

	// Verify git patch upload is now part of the unified artifact upload
	// This step uploads the patch artifact that was generated by the MCP server
	if !strings.Contains(lockContent, "- name: Upload agent artifacts") {
		t.Error("Expected 'Upload agent artifacts' step to be in generated workflow")
	}

	// Verify the upload step uses actions/upload-artifact
	if !strings.Contains(lockContent, "uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f") {
		t.Error("Expected upload-artifact action to be used for unified artifact upload step")
	}

	// Verify the patch path is included in the unified upload (glob pattern for multiple patches)
	if !strings.Contains(lockContent, "/tmp/gh-aw/aw-*.patch") {
		t.Error("Expected artifact path '/tmp/gh-aw/aw-*.patch' in unified upload")
	}

	// Verify the upload step has ignore for missing files
	if !strings.Contains(lockContent, "if-no-files-found: ignore") {
		t.Error("Expected 'if-no-files-found: ignore' in upload step")
	}

	// Verify the upload step runs with if: always()
	uploadArtifactsIndex := strings.Index(lockContent, "- name: Upload agent artifacts")
	if uploadArtifactsIndex == -1 {
		t.Fatal("Upload agent artifacts step not found")
	}

	// Find the next step after upload artifacts step
	nextUploadStart := uploadArtifactsIndex + len("- name: Upload agent artifacts")
	uploadStepEnd := strings.Index(lockContent[nextUploadStart:], "- name:")
	if uploadStepEnd == -1 {
		uploadStepEnd = len(lockContent) - nextUploadStart
	}
	uploadArtifactsStep := lockContent[uploadArtifactsIndex : nextUploadStart+uploadStepEnd]

	if !strings.Contains(uploadArtifactsStep, "if: always()") {
		t.Error("Expected unified artifact upload step to have 'if: always()' condition")
	}

	t.Logf("Successfully verified git patch workflow (patch now generated in MCP server and uploaded in unified artifact upload)")
}
